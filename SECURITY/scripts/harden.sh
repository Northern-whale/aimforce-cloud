#!/bin/bash
# TARS Security Hardening Script
# Run this script to apply automated security fixes
# Author: Security Specialist Agent
# Date: 2026-02-17

set -e  # Exit on error

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$HOME/Desktop/Tars"
AGENT_DASHBOARD="$PROJECT_ROOT/Projects/agent-dashboard"
POLYMARKET="$PROJECT_ROOT/Projects/polymarket-agents"

echo "üîí TARS Security Hardening Script"
echo "=================================="
echo ""

# Color codes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Logging functions
log_info() { echo -e "${GREEN}[INFO]${NC} $1"; }
log_warn() { echo -e "${YELLOW}[WARN]${NC} $1"; }
log_error() { echo -e "${RED}[ERROR]${NC} $1"; }

# Check if running as root (we DON'T want that)
if [ "$EUID" -eq 0 ]; then 
    log_error "Do not run this script as root!"
    exit 1
fi

# ============================================
# PHASE 1: CRITICAL FIXES
# ============================================
echo ""
echo "üìå Phase 1: Critical Security Fixes"
echo "-----------------------------------"

## 1.1: Generate Strong Secrets
log_info "Generating strong secrets..."

NEXTAUTH_SECRET=$(openssl rand -base64 32)
N8N_WEBHOOK_SECRET=$(openssl rand -hex 32)

log_info "‚úÖ Generated NEXTAUTH_SECRET: ${NEXTAUTH_SECRET:0:10}..."
log_info "‚úÖ Generated N8N_WEBHOOK_SECRET: ${N8N_WEBHOOK_SECRET:0:10}..."

## 1.2: Backup existing .env files
log_info "Backing up existing .env files..."

if [ -f "$AGENT_DASHBOARD/apps/web/.env" ]; then
    cp "$AGENT_DASHBOARD/apps/web/.env" "$AGENT_DASHBOARD/apps/web/.env.backup.$(date +%Y%m%d_%H%M%S)"
    log_info "‚úÖ Backed up agent-dashboard .env"
fi

if [ -f "$PROJECT_ROOT/.env" ]; then
    cp "$PROJECT_ROOT/.env" "$PROJECT_ROOT/.env.backup.$(date +%Y%m%d_%H%M%S)"
    log_info "‚úÖ Backed up root .env"
fi

## 1.3: Update .env with new secrets (manual step - printing instructions)
echo ""
log_warn "‚ö†Ô∏è  MANUAL ACTION REQUIRED:"
echo ""
echo "Update the following files with new secrets:"
echo ""
echo "1. $AGENT_DASHBOARD/apps/web/.env:"
echo "   NEXTAUTH_SECRET=\"$NEXTAUTH_SECRET\""
echo "   N8N_WEBHOOK_SECRET=\"$N8N_WEBHOOK_SECRET\""
echo ""
echo "2. Generate new OWNER_PASSWORD (20+ characters):"
echo "   OWNER_PASSWORD=\"$(openssl rand -base64 24)\""
echo ""
echo "3. ROTATE API KEYS (do this manually via provider dashboards):"
echo "   - Anthropic API Key: https://console.anthropic.com/settings/keys"
echo "   - n8n API Key: https://n8n.srv1378974.hstgr.cloud/settings"
echo ""

read -p "Press Enter after updating secrets to continue..."

# ============================================
# PHASE 2: FIX AUTHENTICATION IMPORTS
# ============================================
echo ""
echo "üìå Phase 2: Fix Authentication Code"
echo "------------------------------------"

log_info "Searching for broken authentication imports..."

# Find all files importing authOptions
BROKEN_FILES=$(find "$AGENT_DASHBOARD/apps/web/src" -name "*.ts" -o -name "*.tsx" | xargs grep -l "authOptions" 2>/dev/null || true)

if [ -n "$BROKEN_FILES" ]; then
    log_warn "Found files with broken auth imports:"
    echo "$BROKEN_FILES"
    echo ""
    log_warn "‚ö†Ô∏è  MANUAL FIX REQUIRED:"
    echo "Replace 'authOptions' with 'auth()' in these files:"
    echo ""
    echo "OLD:"
    echo "  import { getServerSession } from 'next-auth';"
    echo "  import { authOptions } from '@/lib/auth';"
    echo "  const session = await getServerSession(authOptions);"
    echo ""
    echo "NEW:"
    echo "  import { auth } from '@/lib/auth';"
    echo "  const session = await auth();"
    echo ""
else
    log_info "‚úÖ No broken auth imports found"
fi

# ============================================
# PHASE 3: ADD INPUT VALIDATION
# ============================================
echo ""
echo "üìå Phase 3: Add Input Validation"
echo "---------------------------------"

log_info "Installing Zod for schema validation..."

cd "$AGENT_DASHBOARD/apps/web"
if command -v pnpm &> /dev/null; then
    pnpm add zod
    log_info "‚úÖ Installed zod via pnpm"
else
    npm install zod
    log_info "‚úÖ Installed zod via npm"
fi

# Create validation schemas file
SCHEMAS_FILE="$AGENT_DASHBOARD/apps/web/src/lib/validation.ts"

log_info "Creating validation schemas..."

cat > "$SCHEMAS_FILE" << 'EOF'
import { z } from 'zod';

/**
 * Validation schemas for API inputs
 * Generated by TARS Security Hardening Script
 */

// Phone number validation (E.164 format)
export const PhoneSchema = z.string()
  .regex(/^\+?[1-9]\d{1,14}$/, 'Invalid phone number format')
  .optional();

// Call log webhook data
export const CallDataSchema = z.object({
  externalId: z.string().max(100).optional(),
  phoneNumber: PhoneSchema,
  direction: z.enum(['inbound', 'outbound']),
  status: z.enum(['completed', 'failed', 'busy', 'no-answer', 'in-progress']),
  duration: z.number().int().min(0).max(7200).optional(),
  summary: z.string().max(5000).optional(),
  transcript: z.string().max(50000).optional(),
  sentiment: z.enum(['positive', 'neutral', 'negative']).optional(),
  transferredTo: PhoneSchema,
  metadata: z.record(z.any()).optional(),
  category: z.enum(['product_inquiry', 'complaint', 'general', 'wholesale']).optional(),
  aiResolved: z.boolean().optional(),
  transferred: z.boolean().optional(),
  topicTags: z.array(z.string()).optional(),
  customerIntent: z.enum(['buying', 'browsing', 'complaining', 'information']).optional(),
});

// Product data
export const ProductSchema = z.object({
  name: z.string().min(1).max(200),
  brand: z.string().min(1).max(100),
  origin: z.string().min(1).max(100),
  price: z.number().positive().max(1000000),
  priceUSD: z.number().positive().max(1000000).optional(),
  strength: z.enum(['mild', 'medium', 'medium-full', 'full']),
  length: z.number().int().min(50).max(300).optional(),
  inStock: z.boolean().optional(),
  stock: z.number().int().min(0).max(100000).optional(),
  description: z.string().max(5000).optional(),
  imageUrl: z.string().url().max(500).optional(),
  category: z.enum(['premium', 'standard', 'exclusive']),
});

// Webhook event
export const WebhookEventSchema = z.object({
  type: z.string().min(1).max(50),
  data: z.record(z.any()),
});

// Sanitize string input (remove null bytes, control characters)
export function sanitizeString(input: string): string {
  return input
    .replace(/\x00/g, '')  // Remove null bytes
    .replace(/[\x00-\x1F\x7F]/g, '')  // Remove control characters
    .trim();
}

// Validate and sanitize all string fields in an object
export function sanitizeObject<T extends Record<string, any>>(obj: T): T {
  const sanitized: any = {};
  for (const [key, value] of Object.entries(obj)) {
    if (typeof value === 'string') {
      sanitized[key] = sanitizeString(value);
    } else if (typeof value === 'object' && value !== null) {
      sanitized[key] = sanitizeObject(value);
    } else {
      sanitized[key] = value;
    }
  }
  return sanitized as T;
}
EOF

log_info "‚úÖ Created validation schemas at src/lib/validation.ts"

# ============================================
# PHASE 4: SECURITY HEADERS
# ============================================
echo ""
echo "üìå Phase 4: Configure Security Headers"
echo "---------------------------------------"

log_info "Updating next.config.ts with security headers..."

NEXT_CONFIG="$AGENT_DASHBOARD/apps/web/next.config.ts"

# Check if security headers already exist
if grep -q "X-Frame-Options" "$NEXT_CONFIG" 2>/dev/null; then
    log_info "‚úÖ Security headers already configured"
else
    log_warn "‚ö†Ô∏è  MANUAL ACTION REQUIRED:"
    echo ""
    echo "Add the following to $NEXT_CONFIG:"
    echo ""
    cat << 'EOF'
import type { NextConfig } from 'next';

const config: NextConfig = {
  // ... existing config

  async headers() {
    return [
      {
        source: '/:path*',
        headers: [
          {
            key: 'X-Frame-Options',
            value: 'DENY',
          },
          {
            key: 'X-Content-Type-Options',
            value: 'nosniff',
          },
          {
            key: 'Referrer-Policy',
            value: 'strict-origin-when-cross-origin',
          },
          {
            key: 'Permissions-Policy',
            value: 'geolocation=(), microphone=(), camera=()',
          },
          {
            key: 'Strict-Transport-Security',
            value: 'max-age=31536000; includeSubDomains',
          },
        ],
      },
    ];
  },

  // Limit request body size
  experimental: {
    serverActions: {
      bodySizeLimit: '1mb',
    },
  },
};

export default config;
EOF
    echo ""
fi

# ============================================
# PHASE 5: RATE LIMITING
# ============================================
echo ""
echo "üìå Phase 5: Install Rate Limiting"
echo "----------------------------------"

log_info "Installing @upstash/ratelimit..."

cd "$AGENT_DASHBOARD/apps/web"
if command -v pnpm &> /dev/null; then
    pnpm add @upstash/ratelimit @upstash/redis
else
    npm install @upstash/ratelimit @upstash/redis
fi

log_info "‚úÖ Installed rate limiting packages"

# Create rate limiting utility
RATELIMIT_FILE="$AGENT_DASHBOARD/apps/web/src/lib/ratelimit.ts"

cat > "$RATELIMIT_FILE" << 'EOF'
import { Ratelimit } from '@upstash/ratelimit';
import { Redis } from '@upstash/redis';

/**
 * Rate limiting configuration
 * Uses Upstash Redis for distributed rate limiting
 * 
 * For local development without Redis:
 * Use in-memory rate limiting (not production-safe)
 */

// Initialize Redis (requires UPSTASH_REDIS_REST_URL and UPSTASH_REDIS_REST_TOKEN)
const redis = process.env.UPSTASH_REDIS_REST_URL
  ? new Redis({
      url: process.env.UPSTASH_REDIS_REST_URL,
      token: process.env.UPSTASH_REDIS_REST_TOKEN!,
    })
  : null;

// Fallback in-memory cache for development
const cache = new Map<string, { count: number; reset: number }>();

function inMemoryRateLimit(key: string, limit: number, window: number): boolean {
  const now = Date.now();
  const entry = cache.get(key);

  if (!entry || entry.reset < now) {
    cache.set(key, { count: 1, reset: now + window });
    return true;
  }

  if (entry.count >= limit) {
    return false;
  }

  entry.count++;
  return true;
}

// Auth endpoints: 5 requests per 15 minutes
export const authLimiter = redis
  ? new Ratelimit({
      redis,
      limiter: Ratelimit.slidingWindow(5, '15 m'),
    })
  : {
      limit: async (key: string) => ({
        success: inMemoryRateLimit(key, 5, 15 * 60 * 1000),
        limit: 5,
        remaining: 0,
        reset: Date.now() + 15 * 60 * 1000,
      }),
    };

// API endpoints: 100 requests per minute
export const apiLimiter = redis
  ? new Ratelimit({
      redis,
      limiter: Ratelimit.slidingWindow(100, '1 m'),
    })
  : {
      limit: async (key: string) => ({
        success: inMemoryRateLimit(key, 100, 60 * 1000),
        limit: 100,
        remaining: 0,
        reset: Date.now() + 60 * 1000,
      }),
    };

// Webhook endpoints: 60 requests per minute
export const webhookLimiter = redis
  ? new Ratelimit({
      redis,
      limiter: Ratelimit.slidingWindow(60, '1 m'),
    })
  : {
      limit: async (key: string) => ({
        success: inMemoryRateLimit(key, 60, 60 * 1000),
        limit: 60,
        remaining: 0,
        reset: Date.now() + 60 * 1000,
      }),
    };

// Helper to get client IP
export function getClientIp(request: Request): string {
  const forwarded = request.headers.get('x-forwarded-for');
  const realIp = request.headers.get('x-real-ip');
  
  if (forwarded) {
    return forwarded.split(',')[0].trim();
  }
  
  if (realIp) {
    return realIp.trim();
  }
  
  return 'unknown';
}
EOF

log_info "‚úÖ Created rate limiting utilities at src/lib/ratelimit.ts"

# ============================================
# PHASE 6: DEPENDENCY AUDIT
# ============================================
echo ""
echo "üìå Phase 6: Audit Dependencies"
echo "-------------------------------"

log_info "Running npm audit on Agent Dashboard..."

cd "$AGENT_DASHBOARD/apps/web"

# Create package-lock if it doesn't exist
if [ ! -f "package-lock.json" ]; then
    log_info "Creating package-lock.json..."
    npm install --package-lock-only
fi

# Run audit
npm audit --audit-level=moderate || log_warn "‚ö†Ô∏è  Vulnerabilities found - review npm audit output"

log_info "Checking Polymarket Agents dependencies..."
cd "$POLYMARKET"

# Check if pip-audit is installed
if ! command -v pip-audit &> /dev/null; then
    log_info "Installing pip-audit..."
    pip3 install pip-audit
fi

pip-audit || log_warn "‚ö†Ô∏è  Python vulnerabilities found - review pip-audit output"

# ============================================
# PHASE 7: GIT SECURITY
# ============================================
echo ""
echo "üìå Phase 7: Git Security Checks"
echo "--------------------------------"

log_info "Ensuring .env files are in .gitignore..."

cd "$PROJECT_ROOT"

# Check root .gitignore
if [ ! -f ".gitignore" ]; then
    log_warn "Creating root .gitignore..."
    cat > .gitignore << EOF
.env
.env.local
.env.*.local
*.db
*.db-journal
node_modules/
.DS_Store
EOF
else
    if ! grep -q "^\.env$" .gitignore; then
        echo ".env" >> .gitignore
        log_info "‚úÖ Added .env to .gitignore"
    fi
fi

# Check if .env is tracked in git
if git ls-files --error-unmatch .env 2>/dev/null; then
    log_error "‚ö†Ô∏è  .env is tracked in git! Remove it:"
    echo "  git rm --cached .env"
    echo "  git commit -m 'Remove .env from git'"
fi

log_info "Scanning git history for secrets..."
SECRETS_FOUND=$(git log --all --full-history -p -- '*.env' 2>/dev/null | grep -c "API_KEY\|SECRET\|PASSWORD" || echo "0")

if [ "$SECRETS_FOUND" -gt 0 ]; then
    log_warn "‚ö†Ô∏è  Found $SECRETS_FOUND potential secrets in git history!"
    echo "  Review git history manually and consider using BFG Repo-Cleaner"
else
    log_info "‚úÖ No obvious secrets found in git history"
fi

# ============================================
# PHASE 8: DATABASE SECURITY
# ============================================
echo ""
echo "üìå Phase 8: Database Security"
echo "------------------------------"

log_info "Setting up automated database backups..."

BACKUP_SCRIPT="$SCRIPT_DIR/backup-db.sh"

cat > "$BACKUP_SCRIPT" << 'EOF'
#!/bin/bash
# Automated database backup script

BACKUP_DIR="$HOME/Desktop/Tars/SECURITY/backups"
DB_PATH="$HOME/Desktop/Tars/Projects/agent-dashboard/apps/web/prisma/dev.db"

mkdir -p "$BACKUP_DIR"

TIMESTAMP=$(date +%Y%m%d_%H%M%S)
BACKUP_FILE="$BACKUP_DIR/dev.db.$TIMESTAMP"

if [ -f "$DB_PATH" ]; then
    cp "$DB_PATH" "$BACKUP_FILE"
    echo "‚úÖ Database backed up to $BACKUP_FILE"
    
    # Keep only last 30 backups
    ls -t "$BACKUP_DIR"/dev.db.* | tail -n +31 | xargs rm -f 2>/dev/null
else
    echo "‚ùå Database not found at $DB_PATH"
    exit 1
fi
EOF

chmod +x "$BACKUP_SCRIPT"

log_info "‚úÖ Created backup script at $BACKUP_SCRIPT"
log_info "To automate: Add to cron: 0 2 * * * $BACKUP_SCRIPT"

# ============================================
# PHASE 9: CREATE MONITORING SCRIPT
# ============================================
echo ""
echo "üìå Phase 9: Security Monitoring"
echo "--------------------------------"

MONITOR_SCRIPT="$SCRIPT_DIR/monitor-security.sh"

cat > "$MONITOR_SCRIPT" << 'EOF'
#!/bin/bash
# Security monitoring script
# Run this daily to check for security issues

PROJECT_ROOT="$HOME/Desktop/Tars"

echo "üîç TARS Security Monitoring"
echo "==========================="
echo ""

# Check for exposed .env files
echo "Checking for exposed .env files..."
find "$PROJECT_ROOT" -name ".env" -not -path "*/node_modules/*" | while read -r file; do
    if git ls-files --error-unmatch "$file" 2>/dev/null; then
        echo "‚ö†Ô∏è  ALERT: $file is tracked in git!"
    fi
done

# Check for weak passwords in .env
echo "Checking for weak passwords..."
grep -r "PASSWORD=.*" "$PROJECT_ROOT"/.env* 2>/dev/null | while read -r line; do
    if echo "$line" | grep -E "PASSWORD=(admin|password|123|test|dev)" > /dev/null; then
        echo "‚ö†Ô∏è  ALERT: Weak password found: $line"
    fi
done

# Check for running services on unexpected ports
echo "Checking for open ports..."
netstat -tuln 2>/dev/null | grep LISTEN || echo "No open ports detected (netstat not available)"

# Check for failed login attempts (if logs exist)
if [ -f "$PROJECT_ROOT/logs/auth.log" ]; then
    FAILED_LOGINS=$(grep "Failed login" "$PROJECT_ROOT/logs/auth.log" | wc -l)
    if [ "$FAILED_LOGINS" -gt 10 ]; then
        echo "‚ö†Ô∏è  ALERT: $FAILED_LOGINS failed login attempts detected!"
    fi
fi

echo ""
echo "‚úÖ Monitoring complete"
EOF

chmod +x "$MONITOR_SCRIPT"

log_info "‚úÖ Created monitoring script at $MONITOR_SCRIPT"
log_info "Run daily: $MONITOR_SCRIPT"

# ============================================
# SUMMARY
# ============================================
echo ""
echo "============================================"
echo "‚úÖ Security Hardening Complete!"
echo "============================================"
echo ""
echo "üìã Summary of Changes:"
echo "  ‚úÖ Generated strong secrets (update .env files manually)"
echo "  ‚úÖ Installed input validation (Zod)"
echo "  ‚úÖ Created validation schemas"
echo "  ‚úÖ Installed rate limiting packages"
echo "  ‚úÖ Created rate limiting utilities"
echo "  ‚úÖ Audited dependencies"
echo "  ‚úÖ Created backup script"
echo "  ‚úÖ Created monitoring script"
echo ""
echo "‚ö†Ô∏è  MANUAL ACTIONS REQUIRED:"
echo "  1. Update .env files with new secrets (see output above)"
echo "  2. Rotate API keys via provider dashboards"
echo "  3. Fix authentication imports in API routes"
echo "  4. Add security headers to next.config.ts"
echo "  5. Apply input validation to webhook handlers"
echo "  6. Set up Upstash Redis for rate limiting (or use in-memory for dev)"
echo "  7. Schedule daily backups (cron)"
echo "  8. Review SECURITY-AUDIT.md for remaining issues"
echo ""
echo "üìö Next Steps:"
echo "  - Read: $HOME/Desktop/Tars/SECURITY/SECURITY-CHECKLIST.md"
echo "  - Implement: Remaining High/Medium severity fixes"
echo "  - Test: All authentication and authorization flows"
echo "  - Deploy: After verification"
echo ""
echo "üîê Stay secure! üöÄ"
